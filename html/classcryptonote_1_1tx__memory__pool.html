<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monero: cryptonote::tx_memory_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Monero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecryptonote.html">cryptonote</a></li><li class="navelem"><a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classcryptonote_1_1tx__memory__pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cryptonote::tx_memory_pool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transaction pool, handles transactions which are not part of a block.  
 <a href="classcryptonote_1_1tx__memory__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tx__pool_8h_source.html">tx_pool.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for cryptonote::tx_memory_pool:</div>
<div class="dyncontent">
<div class="center"><img src="classcryptonote_1_1tx__memory__pool__coll__graph.png" border="0" usemap="#cryptonote_1_1tx__memory__pool_coll__map" alt="Collaboration graph"/></div>
<map name="cryptonote_1_1tx__memory__pool_coll__map" id="cryptonote_1_1tx__memory__pool_coll__map">
<area shape="rect" title="Transaction pool, handles transactions which are not part of a block." alt="" coords="1512,591,1723,617"/>
<area shape="rect" href="classcryptonote_1_1Blockchain.html" title=" " alt="" coords="1908,596,2079,623"/>
<area shape="rect" href="classservice__nodes_1_1service__node__list.html" title=" " alt="" coords="2317,542,2488,583"/>
<area shape="rect" href="classcryptonote_1_1checkpoints.html" title="A container for blockchain checkpoints." alt="" coords="1528,969,1707,996"/>
<area shape="rect" title=" " alt="" coords="5,751,80,777"/>
<area shape="rect" href="classcryptonote_1_1BlockchainDB.html" title="The BlockchainDB backing store interface declaration/contract." alt="" coords="1073,993,1263,1020"/>
<area shape="rect" href="structons_1_1name__system__db.html" title=" " alt="" coords="1084,820,1252,847"/>
<area shape="rect" href="structcryptonote_1_1block.html" title=" " alt="" coords="1550,363,1685,389"/>
<area shape="rect" href="structcryptonote_1_1block__header.html" title=" " alt="" coords="1075,329,1261,356"/>
<area shape="rect" href="classcryptonote_1_1transaction__prefix.html" title=" " alt="" coords="429,565,603,606"/>
<area shape="rect" href="structrct_1_1rctSigBase.html" title=" " alt="" coords="251,751,367,777"/>
<area shape="rect" title=" " alt="" coords="690,723,750,749"/>
<area shape="rect" href="classcryptonote_1_1transaction.html" title=" " alt="" coords="1081,493,1255,520"/>
<area shape="rect" href="structcryptonote_1_1account__public__address.html" title=" " alt="" coords="1542,227,1693,269"/>
<area shape="rect" href="structcrypto_1_1public__key.html" title=" " alt="" coords="1098,197,1238,224"/>
<area shape="rect" href="structservice__nodes_1_1service__node__keys.html" title="Collection of keys used by a service node." alt="" coords="1532,117,1703,158"/>
<area shape="rect" href="structcrypto_1_1ec__point.html" title=" " alt="" coords="657,133,783,160"/>
<area shape="rect" href="structcrypto_1_1x25519__public__key.html" title=" " alt="" coords="1071,133,1265,160"/>
<area shape="rect" href="structcrypto_1_1ed25519__public__key.html" title=" " alt="" coords="1067,83,1269,109"/>
<area shape="rect" href="structcrypto_1_1bytes.html" title=" " alt="" coords="238,126,381,167"/>
<area shape="rect" href="structservice__nodes_1_1service__node__list_1_1data__for__serialization.html" title=" " alt="" coords="1875,647,2112,689"/>
<area shape="rect" href="classons_1_1sql__compiled__statement.html" title=" " alt="" coords="1511,839,1724,865"/>
<area shape="rect" href="structcrypto_1_1hash.html" title=" " alt="" coords="669,441,771,468"/>
<area shape="rect" href="structcrypto_1_1bytes.html" title=" " alt="" coords="230,434,389,475"/>
<area shape="rect" href="structcryptonote_1_1pulse__header.html" title=" " alt="" coords="627,312,813,339"/>
<area shape="rect" href="structcryptonote_1_1pulse__random__value.html" title=" " alt="" coords="213,302,405,343"/>
<area shape="rect" href="structrct_1_1rctSig.html" title=" " alt="" coords="678,659,762,685"/>
<area shape="rect" href="structrct_1_1key.html" title=" " alt="" coords="7,1019,78,1045"/>
<area shape="rect" href="structrct_1_1rctSigPrunable.html" title=" " alt="" coords="239,659,380,685"/>
<area shape="rect" href="classtools_1_1periodic__task.html" title=" " alt="" coords="1093,607,1243,633"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcryptonote_1_1tx__memory__pool_1_1tx__stats.html">tx_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="classcryptonote_1_1tx__memory__pool.html#afc6a4f1b878b42f63e3fbf99643c591c" title="get a summary statistics of all transaction hashes in the pool">get_transaction_stats()</a>  <a href="structcryptonote_1_1tx__memory__pool_1_1tx__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac8db608d610e9b31288681ab018ae2e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">key_images_container</a> = std::unordered_map&lt; <a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a>, std::unordered_set&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac8db608d610e9b31288681ab018ae2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">map key images to transactions which spent them  <a href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">More...</a><br /></td></tr>
<tr class="separator:ac8db608d610e9b31288681ab018ae2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a992c709afc7268d0d9cf23485095d98f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a992c709afc7268d0d9cf23485095d98f">tx_memory_pool</a> (<a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> &amp;bchs)</td></tr>
<tr class="memdesc:a992c709afc7268d0d9cf23485095d98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classcryptonote_1_1tx__memory__pool.html#a992c709afc7268d0d9cf23485095d98f">More...</a><br /></td></tr>
<tr class="separator:a992c709afc7268d0d9cf23485095d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a78c369e288d5d5ff853cc5f42325e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ae3a78c369e288d5d5ff853cc5f42325e">tx_memory_pool</a> (const <a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a> &amp;)=delete</td></tr>
<tr class="separator:ae3a78c369e288d5d5ff853cc5f42325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b0ca004bbdd657127cb3e85d986619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a48b0ca004bbdd657127cb3e85d986619">operator=</a> (const <a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a> &amp;)=delete</td></tr>
<tr class="separator:a48b0ca004bbdd657127cb3e85d986619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5946446c0e38b9e05b10bc658f949c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ad5946446c0e38b9e05b10bc658f949c9">add_tx</a> (<a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx, const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;id, const std::string &amp;blob, size_t tx_weight, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;tvc, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;opts, <a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a> hf_version, uint64_t *blink_rollback_height=nullptr)</td></tr>
<tr class="memdesc:ad5946446c0e38b9e05b10bc658f949c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a transaction to the transaction pool  <a href="classcryptonote_1_1tx__memory__pool.html#ad5946446c0e38b9e05b10bc658f949c9">More...</a><br /></td></tr>
<tr class="separator:ad5946446c0e38b9e05b10bc658f949c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7005556ce18cb58faf0d6045b0dd22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#aaa7005556ce18cb58faf0d6045b0dd22">add_tx</a> (<a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;tvc, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;opts, <a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a> hf_version)</td></tr>
<tr class="memdesc:aaa7005556ce18cb58faf0d6045b0dd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a transaction to the transaction pool  <a href="classcryptonote_1_1tx__memory__pool.html#aaa7005556ce18cb58faf0d6045b0dd22">More...</a><br /></td></tr>
<tr class="separator:aaa7005556ce18cb58faf0d6045b0dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013deee6f30a649f65430ab8f27aa1ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a013deee6f30a649f65430ab8f27aa1ea">add_new_blink</a> (const std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt; &amp;blink, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;tvc, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;blink_exists)</td></tr>
<tr class="memdesc:a013deee6f30a649f65430ab8f27aa1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to add a blink transaction to the transaction pool.  <a href="classcryptonote_1_1tx__memory__pool.html#a013deee6f30a649f65430ab8f27aa1ea">More...</a><br /></td></tr>
<tr class="separator:a013deee6f30a649f65430ab8f27aa1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d69f56ad1b8807de5d3ff108543433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ab3d69f56ad1b8807de5d3ff108543433">add_existing_blink</a> (std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt; blink)</td></tr>
<tr class="memdesc:ab3d69f56ad1b8807de5d3ff108543433"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to add blink transaction information about an existing blink transaction  <a href="classcryptonote_1_1tx__memory__pool.html#ab3d69f56ad1b8807de5d3ff108543433">More...</a><br /></td></tr>
<tr class="separator:ab3d69f56ad1b8807de5d3ff108543433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9a263a86f5966b6b49421aaed989ec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a4e9a263a86f5966b6b49421aaed989ec">get_blink</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;tx_hash) const</td></tr>
<tr class="memdesc:a4e9a263a86f5966b6b49421aaed989ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">accesses blink tx details if the given tx hash is a known, approved blink tx, nullptr otherwise.  <a href="classcryptonote_1_1tx__memory__pool.html#a4e9a263a86f5966b6b49421aaed989ec">More...</a><br /></td></tr>
<tr class="separator:a4e9a263a86f5966b6b49421aaed989ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99a39234919dfe66897951fa0bb5241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#aa99a39234919dfe66897951fa0bb5241">has_blink</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;tx_hash) const</td></tr>
<tr class="separator:aa99a39234919dfe66897951fa0bb5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60742c292f673da41e8906e1ce18b59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a60742c292f673da41e8906e1ce18b59c">keep_missing_blinks</a> (std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;tx_hashes) const</td></tr>
<tr class="memdesc:a60742c292f673da41e8906e1ce18b59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">modifies a vector of tx hashes to remove any that have known valid blink signatures  <a href="classcryptonote_1_1tx__memory__pool.html#a60742c292f673da41e8906e1ce18b59c">More...</a><br /></td></tr>
<tr class="separator:a60742c292f673da41e8906e1ce18b59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424e94187ab40930a39b273ac6f31d7"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint64_t, <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ab424e94187ab40930a39b273ac6f31d7">get_blink_checksums</a> () const</td></tr>
<tr class="memdesc:ab424e94187ab40930a39b273ac6f31d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns checksums of blink txes included in recently mined blocks and in the mempool  <a href="classcryptonote_1_1tx__memory__pool.html#ab424e94187ab40930a39b273ac6f31d7">More...</a><br /></td></tr>
<tr class="separator:ab424e94187ab40930a39b273ac6f31d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1b40549be4e5ce2575db5736f591ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a9a1b40549be4e5ce2575db5736f591ce">get_mined_blinks</a> (const std::set&lt; uint64_t &gt; &amp;heights) const</td></tr>
<tr class="memdesc:a9a1b40549be4e5ce2575db5736f591ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the hashes of any non-immutable blink transactions mined in the given heights. A height of 0 is allowed: it indicates blinks in the mempool.  <a href="classcryptonote_1_1tx__memory__pool.html#a9a1b40549be4e5ce2575db5736f591ce">More...</a><br /></td></tr>
<tr class="separator:a9a1b40549be4e5ce2575db5736f591ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bba96b565d97b87f2a90fef343eba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#af2bba96b565d97b87f2a90fef343eba0">take_tx</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;id, <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx, std::string &amp;txblob, size_t &amp;tx_weight, uint64_t &amp;fee, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;relayed, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;do_not_relay, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;double_spend_seen)</td></tr>
<tr class="memdesc:af2bba96b565d97b87f2a90fef343eba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes a transaction with the given hash from the pool  <a href="classcryptonote_1_1tx__memory__pool.html#af2bba96b565d97b87f2a90fef343eba0">More...</a><br /></td></tr>
<tr class="separator:af2bba96b565d97b87f2a90fef343eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c005079be92dc34c487216278086e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a54c005079be92dc34c487216278086e4">have_tx</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;id) const</td></tr>
<tr class="memdesc:a54c005079be92dc34c487216278086e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the pool has a transaction with the given hash  <a href="classcryptonote_1_1tx__memory__pool.html#a54c005079be92dc34c487216278086e4">More...</a><br /></td></tr>
<tr class="separator:a54c005079be92dc34c487216278086e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6710a00d13e4ddc0a1974b391ae85aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ae6710a00d13e4ddc0a1974b391ae85aa">have_txs</a> (const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;hashes) const</td></tr>
<tr class="memdesc:ae6710a00d13e4ddc0a1974b391ae85aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether the given tx hashes are in the mempool  <a href="classcryptonote_1_1tx__memory__pool.html#ae6710a00d13e4ddc0a1974b391ae85aa">More...</a><br /></td></tr>
<tr class="separator:ae6710a00d13e4ddc0a1974b391ae85aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d217ba322d9d2e06500411fffe07d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a5d217ba322d9d2e06500411fffe07d67">on_blockchain_inc</a> (<a class="el" href="structcryptonote_1_1block.html">block</a> const &amp;blk)</td></tr>
<tr class="memdesc:a5d217ba322d9d2e06500411fffe07d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">action to take when notified of a block added to the blockchain  <a href="classcryptonote_1_1tx__memory__pool.html#a5d217ba322d9d2e06500411fffe07d67">More...</a><br /></td></tr>
<tr class="separator:a5d217ba322d9d2e06500411fffe07d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6da06ddc8334f31dd69aecffdcf948e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ae6da06ddc8334f31dd69aecffdcf948e">on_blockchain_dec</a> ()</td></tr>
<tr class="memdesc:ae6da06ddc8334f31dd69aecffdcf948e"><td class="mdescLeft">&#160;</td><td class="mdescRight">action to take when notified of a block removed from the blockchain  <a href="classcryptonote_1_1tx__memory__pool.html#ae6da06ddc8334f31dd69aecffdcf948e">More...</a><br /></td></tr>
<tr class="separator:ae6da06ddc8334f31dd69aecffdcf948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b272997a403b2f451820e890ba628b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a1b272997a403b2f451820e890ba628b0">on_idle</a> ()</td></tr>
<tr class="memdesc:a1b272997a403b2f451820e890ba628b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">action to take periodically  <a href="classcryptonote_1_1tx__memory__pool.html#a1b272997a403b2f451820e890ba628b0">More...</a><br /></td></tr>
<tr class="separator:a1b272997a403b2f451820e890ba628b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe5dc73d036d7ea07ac632317b6113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ae7fe5dc73d036d7ea07ac632317b6113">add_notify</a> (std::function&lt; void(const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;, const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;, const std::string &amp;blob, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;)&gt; notify)</td></tr>
<tr class="separator:ae7fe5dc73d036d7ea07ac632317b6113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e718457416f64580f4dfdc4e9926cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a0e718457416f64580f4dfdc4e9926cbd">lock</a> () const</td></tr>
<tr class="memdesc:a0e718457416f64580f4dfdc4e9926cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">locks the transaction pool  <a href="classcryptonote_1_1tx__memory__pool.html#a0e718457416f64580f4dfdc4e9926cbd">More...</a><br /></td></tr>
<tr class="separator:a0e718457416f64580f4dfdc4e9926cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011855e34b5f72c21770d3718313ef40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a011855e34b5f72c21770d3718313ef40">unlock</a> () const</td></tr>
<tr class="memdesc:a011855e34b5f72c21770d3718313ef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlocks the transaction pool  <a href="classcryptonote_1_1tx__memory__pool.html#a011855e34b5f72c21770d3718313ef40">More...</a><br /></td></tr>
<tr class="separator:a011855e34b5f72c21770d3718313ef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b8179f3f72c219b0afe760d6df55ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a65b8179f3f72c219b0afe760d6df55ee">try_lock</a> () const</td></tr>
<tr class="separator:a65b8179f3f72c219b0afe760d6df55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010a25d6e7eb662d6c29c732da0ee1c2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a010a25d6e7eb662d6c29c732da0ee1c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a010a25d6e7eb662d6c29c732da0ee1c2">blink_unique_lock</a> (Args &amp;&amp;...args) const</td></tr>
<tr class="memdesc:a010a25d6e7eb662d6c29c732da0ee1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a unique lock on the approved blink tx pool  <a href="classcryptonote_1_1tx__memory__pool.html#a010a25d6e7eb662d6c29c732da0ee1c2">More...</a><br /></td></tr>
<tr class="separator:a010a25d6e7eb662d6c29c732da0ee1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13906ba925503f7de4bacfca1f1497c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af13906ba925503f7de4bacfca1f1497c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#af13906ba925503f7de4bacfca1f1497c">blink_shared_lock</a> (Args &amp;&amp;...args) const</td></tr>
<tr class="memdesc:af13906ba925503f7de4bacfca1f1497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a shared lock on the approved blink tx pool  <a href="classcryptonote_1_1tx__memory__pool.html#af13906ba925503f7de4bacfca1f1497c">More...</a><br /></td></tr>
<tr class="separator:af13906ba925503f7de4bacfca1f1497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef1c5e089c16db7f09595a092d1825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a82ef1c5e089c16db7f09595a092d1825">init</a> (size_t max_txpool_weight=0)</td></tr>
<tr class="memdesc:a82ef1c5e089c16db7f09595a092d1825"><td class="mdescLeft">&#160;</td><td class="mdescRight">loads pool state (if any) from disk, and initializes pool  <a href="classcryptonote_1_1tx__memory__pool.html#a82ef1c5e089c16db7f09595a092d1825">More...</a><br /></td></tr>
<tr class="separator:a82ef1c5e089c16db7f09595a092d1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea956b17732998b8143d6d3d8e0ba7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#afea956b17732998b8143d6d3d8e0ba7b">deinit</a> ()</td></tr>
<tr class="memdesc:afea956b17732998b8143d6d3d8e0ba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to save the transaction pool state to disk  <a href="classcryptonote_1_1tx__memory__pool.html#afea956b17732998b8143d6d3d8e0ba7b">More...</a><br /></td></tr>
<tr class="separator:afea956b17732998b8143d6d3d8e0ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1211f3aefd5033931d168da4e78fd80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a1211f3aefd5033931d168da4e78fd80a">fill_block_template</a> (<a class="el" href="structcryptonote_1_1block.html">block</a> &amp;bl, size_t median_weight, uint64_t already_generated_coins, size_t &amp;total_weight, uint64_t &amp;raw_fee, uint64_t &amp;expected_reward, <a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a> version, uint64_t height)</td></tr>
<tr class="memdesc:a1211f3aefd5033931d168da4e78fd80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses transactions for a block to include.  <a href="classcryptonote_1_1tx__memory__pool.html#a1211f3aefd5033931d168da4e78fd80a">More...</a><br /></td></tr>
<tr class="separator:a1211f3aefd5033931d168da4e78fd80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781505a42371a8461edb4047bf6c2046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a781505a42371a8461edb4047bf6c2046">get_transactions</a> (std::vector&lt; <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &gt; &amp;txs, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> include_unrelayed_txes=<a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>) const</td></tr>
<tr class="memdesc:a781505a42371a8461edb4047bf6c2046"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a list of all transactions in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a781505a42371a8461edb4047bf6c2046">More...</a><br /></td></tr>
<tr class="separator:a781505a42371a8461edb4047bf6c2046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b85b526e1d7cf27a58b076270c52b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a3d0b85b526e1d7cf27a58b076270c52b">get_transaction_hashes</a> (std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;txs, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> include_unrelayed_txes=<a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> include_only_blinked=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>) const</td></tr>
<tr class="memdesc:a3d0b85b526e1d7cf27a58b076270c52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a list of all transaction hashes in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a3d0b85b526e1d7cf27a58b076270c52b">More...</a><br /></td></tr>
<tr class="separator:a3d0b85b526e1d7cf27a58b076270c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6a4f1b878b42f63e3fbf99643c591c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcryptonote_1_1tx__memory__pool_1_1tx__stats.html">tx_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#afc6a4f1b878b42f63e3fbf99643c591c">get_transaction_stats</a> (<a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> include_unrelayed_txes=<a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>) const</td></tr>
<tr class="memdesc:afc6a4f1b878b42f63e3fbf99643c591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a summary statistics of all transaction hashes in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#afc6a4f1b878b42f63e3fbf99643c591c">More...</a><br /></td></tr>
<tr class="separator:afc6a4f1b878b42f63e3fbf99643c591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec13cc81f2955d9f39bf3273791a3e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#aec13cc81f2955d9f39bf3273791a3e21">check_for_key_images</a> (const std::vector&lt; <a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a> &gt; &amp;key_images, std::vector&lt; <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &gt; &amp;spent) const</td></tr>
<tr class="memdesc:aec13cc81f2955d9f39bf3273791a3e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for presence of key images in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#aec13cc81f2955d9f39bf3273791a3e21">More...</a><br /></td></tr>
<tr class="separator:aec13cc81f2955d9f39bf3273791a3e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afa235429f2aad604d7a01bf8117c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a8afa235429f2aad604d7a01bf8117c55">get_transaction</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;h, std::string &amp;txblob) const</td></tr>
<tr class="memdesc:a8afa235429f2aad604d7a01bf8117c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a specific transaction from the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a8afa235429f2aad604d7a01bf8117c55">More...</a><br /></td></tr>
<tr class="separator:a8afa235429f2aad604d7a01bf8117c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9946ac23813b0846275575e79b37bcc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a9946ac23813b0846275575e79b37bcc8">find_transactions</a> (const std::unordered_set&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;tx_hashes, std::vector&lt; std::string &gt; &amp;txblobs) const</td></tr>
<tr class="memdesc:a9946ac23813b0846275575e79b37bcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get specific transactions from the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a9946ac23813b0846275575e79b37bcc8">More...</a><br /></td></tr>
<tr class="separator:a9946ac23813b0846275575e79b37bcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0bbc05821f25c43f87818dd048e2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ada0bbc05821f25c43f87818dd048e2be">get_relayable_transactions</a> (std::vector&lt; std::pair&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::string &gt;&gt; &amp;txs) const</td></tr>
<tr class="memdesc:ada0bbc05821f25c43f87818dd048e2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a list of all relayable transactions and their hashes  <a href="classcryptonote_1_1tx__memory__pool.html#ada0bbc05821f25c43f87818dd048e2be">More...</a><br /></td></tr>
<tr class="separator:ada0bbc05821f25c43f87818dd048e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cf4b37f2feb1653ac96a83945cca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a2a0cf4b37f2feb1653ac96a83945cca3">set_relayable</a> (const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;tx_hashes)</td></tr>
<tr class="memdesc:a2a0cf4b37f2feb1653ac96a83945cca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear transactions' <code>do_not_relay</code> flags (if set) so that they can start being relayed. (Note that it still must satisfy the other conditions of <code>get_relayable_transactions</code> to actually be relayable).  <a href="classcryptonote_1_1tx__memory__pool.html#a2a0cf4b37f2feb1653ac96a83945cca3">More...</a><br /></td></tr>
<tr class="separator:a2a0cf4b37f2feb1653ac96a83945cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0c2d4cc416d504e4ceabbb175edc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#acec0c2d4cc416d504e4ceabbb175edc2">set_relayed</a> (const std::vector&lt; std::pair&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::string &gt;&gt; &amp;txs)</td></tr>
<tr class="memdesc:acec0c2d4cc416d504e4ceabbb175edc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tell the pool that certain transactions were just relayed  <a href="classcryptonote_1_1tx__memory__pool.html#acec0c2d4cc416d504e4ceabbb175edc2">More...</a><br /></td></tr>
<tr class="separator:acec0c2d4cc416d504e4ceabbb175edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac819deab6187cd28a7a1233114b287d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac819deab6187cd28a7a1233114b287d5">get_transactions_count</a> (<a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> include_unrelayed_txes=<a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>) const</td></tr>
<tr class="memdesc:ac819deab6187cd28a7a1233114b287d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the total number of transactions in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#ac819deab6187cd28a7a1233114b287d5">More...</a><br /></td></tr>
<tr class="separator:ac819deab6187cd28a7a1233114b287d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac338181c8cdba5f77b645c530de1de7a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac338181c8cdba5f77b645c530de1de7a">validate</a> (<a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a> version)</td></tr>
<tr class="memdesc:ac338181c8cdba5f77b645c530de1de7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove transactions from the pool which are no longer valid  <a href="classcryptonote_1_1tx__memory__pool.html#ac338181c8cdba5f77b645c530de1de7a">More...</a><br /></td></tr>
<tr class="separator:ac338181c8cdba5f77b645c530de1de7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126ff436715b0012c73a78cc83ca0b1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a7126ff436715b0012c73a78cc83ca0b1">cookie</a> () const</td></tr>
<tr class="memdesc:a7126ff436715b0012c73a78cc83ca0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the cookie  <a href="classcryptonote_1_1tx__memory__pool.html#a7126ff436715b0012c73a78cc83ca0b1">More...</a><br /></td></tr>
<tr class="separator:a7126ff436715b0012c73a78cc83ca0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572c0afc555ae393a8df2dcc0f00673"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ab572c0afc555ae393a8df2dcc0f00673">get_txpool_weight</a> () const</td></tr>
<tr class="memdesc:ab572c0afc555ae393a8df2dcc0f00673"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the cumulative txpool weight in bytes  <a href="classcryptonote_1_1tx__memory__pool.html#ab572c0afc555ae393a8df2dcc0f00673">More...</a><br /></td></tr>
<tr class="separator:ab572c0afc555ae393a8df2dcc0f00673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b8b8aba76dc6dac3ef345367574f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a76b8b8aba76dc6dac3ef345367574f69">set_txpool_max_weight</a> (size_t bytes)</td></tr>
<tr class="memdesc:a76b8b8aba76dc6dac3ef345367574f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the max cumulative txpool weight in bytes  <a href="classcryptonote_1_1tx__memory__pool.html#a76b8b8aba76dc6dac3ef345367574f69">More...</a><br /></td></tr>
<tr class="separator:a76b8b8aba76dc6dac3ef345367574f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5681132864da1374850641c1e35f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">key_images_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a3c5681132864da1374850641c1e35f2e">get_spent_key_images</a> (<a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> already_locked=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="separator:a3c5681132864da1374850641c1e35f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad93aa45381a8ba23afbba87e50aa6e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ad93aa45381a8ba23afbba87e50aa6e4b">insert_key_images</a> (const <a class="el" href="classcryptonote_1_1transaction__prefix.html">transaction_prefix</a> &amp;tx, const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;txid, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> kept_by_block)</td></tr>
<tr class="memdesc:ad93aa45381a8ba23afbba87e50aa6e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert key images into m_spent_key_images  <a href="classcryptonote_1_1tx__memory__pool.html#ad93aa45381a8ba23afbba87e50aa6e4b">More...</a><br /></td></tr>
<tr class="separator:ad93aa45381a8ba23afbba87e50aa6e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad00ed4cce2351c261925dfbde1b0a1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#aad00ed4cce2351c261925dfbde1b0a1e">remove_stuck_transactions</a> ()</td></tr>
<tr class="memdesc:aad00ed4cce2351c261925dfbde1b0a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove old transactions from the pool  <a href="classcryptonote_1_1tx__memory__pool.html#aad00ed4cce2351c261925dfbde1b0a1e">More...</a><br /></td></tr>
<tr class="separator:aad00ed4cce2351c261925dfbde1b0a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc095de20f5654b4642f947a08d5e6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#adc095de20f5654b4642f947a08d5e6ec">have_tx_keyimg_as_spent</a> (const <a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a> &amp;key_im) const</td></tr>
<tr class="memdesc:adc095de20f5654b4642f947a08d5e6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a transaction in the pool has a given spent key image  <a href="classcryptonote_1_1tx__memory__pool.html#adc095de20f5654b4642f947a08d5e6ec">More...</a><br /></td></tr>
<tr class="separator:adc095de20f5654b4642f947a08d5e6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac624b3e7995eaecac7bd77d28b21836d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac624b3e7995eaecac7bd77d28b21836d">have_duplicated_non_standard_tx</a> (<a class="el" href="classcryptonote_1_1transaction.html">transaction</a> const &amp;tx, <a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a> version) const</td></tr>
<tr class="memdesc:ac624b3e7995eaecac7bd77d28b21836d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a tx that does not have a key-image component has a duplicate in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#ac624b3e7995eaecac7bd77d28b21836d">More...</a><br /></td></tr>
<tr class="separator:ac624b3e7995eaecac7bd77d28b21836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360c129a0323bf11804be1764102f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a9360c129a0323bf11804be1764102f55">have_tx_keyimges_as_spent</a> (const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx, std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; *conflicting=nullptr) const</td></tr>
<tr class="memdesc:a9360c129a0323bf11804be1764102f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if any spent key image in a transaction is in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a9360c129a0323bf11804be1764102f55">More...</a><br /></td></tr>
<tr class="separator:a9360c129a0323bf11804be1764102f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fea8a79996be4896421a1d492414098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a3fea8a79996be4896421a1d492414098">remove_transaction_keyimages</a> (const <a class="el" href="classcryptonote_1_1transaction__prefix.html">transaction_prefix</a> &amp;tx, const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;txid)</td></tr>
<tr class="memdesc:a3fea8a79996be4896421a1d492414098"><td class="mdescLeft">&#160;</td><td class="mdescRight">forget a transaction's spent key images  <a href="classcryptonote_1_1tx__memory__pool.html#a3fea8a79996be4896421a1d492414098">More...</a><br /></td></tr>
<tr class="separator:a3fea8a79996be4896421a1d492414098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223200675e9cb2dc9c748163664fc7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a223200675e9cb2dc9c748163664fc7e0">is_transaction_ready_to_go</a> (<a class="el" href="structcryptonote_1_1txpool__tx__meta__t.html">txpool_tx_meta_t</a> &amp;txd, const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;txid, const std::string &amp;txblob, <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx) const</td></tr>
<tr class="memdesc:a223200675e9cb2dc9c748163664fc7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a transaction is a valid candidate for inclusion in a block  <a href="classcryptonote_1_1tx__memory__pool.html#a223200675e9cb2dc9c748163664fc7e0">More...</a><br /></td></tr>
<tr class="separator:a223200675e9cb2dc9c748163664fc7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab421ff4baa8437324f4e3a6b2fb4e138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ab421ff4baa8437324f4e3a6b2fb4e138">mark_double_spend</a> (const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;tx)</td></tr>
<tr class="memdesc:ab421ff4baa8437324f4e3a6b2fb4e138"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark all transactions double spending the one passed  <a href="classcryptonote_1_1tx__memory__pool.html#ab421ff4baa8437324f4e3a6b2fb4e138">More...</a><br /></td></tr>
<tr class="separator:ab421ff4baa8437324f4e3a6b2fb4e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2371b71c2f9d0307a28fc2f9638c00f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a2371b71c2f9d0307a28fc2f9638c00f3">remove_tx</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;txid, const <a class="el" href="structcryptonote_1_1txpool__tx__meta__t.html">txpool_tx_meta_t</a> *meta=nullptr, const sorted_tx_container::iterator *stc_it=nullptr)</td></tr>
<tr class="memdesc:a2371b71c2f9d0307a28fc2f9638c00f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a transaction from the mempool  <a href="classcryptonote_1_1tx__memory__pool.html#a2371b71c2f9d0307a28fc2f9638c00f3">More...</a><br /></td></tr>
<tr class="separator:a2371b71c2f9d0307a28fc2f9638c00f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace60037187690f98fe07f18c3daf32f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ace60037187690f98fe07f18c3daf32f4">prune</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;skip)</td></tr>
<tr class="memdesc:ace60037187690f98fe07f18c3daf32f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">prune lowest fee/byte txes till we're not above bytes  <a href="classcryptonote_1_1tx__memory__pool.html#ace60037187690f98fe07f18c3daf32f4">More...</a><br /></td></tr>
<tr class="separator:ace60037187690f98fe07f18c3daf32f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb2c77087275ab6ff7759b773f8de15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#adfb2c77087275ab6ff7759b773f8de15">remove_blink_conflicts</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;id, const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;conflict_txs, uint64_t *blink_rollback_height)</td></tr>
<tr class="memdesc:adfb2c77087275ab6ff7759b773f8de15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to add a blink tx "by force", removing conflicting non-blink txs.  <a href="classcryptonote_1_1tx__memory__pool.html#adfb2c77087275ab6ff7759b773f8de15">More...</a><br /></td></tr>
<tr class="separator:adfb2c77087275ab6ff7759b773f8de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84ffb957eeda11ec3ef752bb9cb2fc"><td class="memItemLeft" align="right" valign="top">sorted_tx_container::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a0a84ffb957eeda11ec3ef752bb9cb2fc">find_tx_in_sorted_container</a> (const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;id) const</td></tr>
<tr class="memdesc:a0a84ffb957eeda11ec3ef752bb9cb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to a transaction in the sorted container  <a href="classcryptonote_1_1tx__memory__pool.html#a0a84ffb957eeda11ec3ef752bb9cb2fc">More...</a><br /></td></tr>
<tr class="separator:a0a84ffb957eeda11ec3ef752bb9cb2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d30e317c1b946903d0ed3170bdc109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ae6d30e317c1b946903d0ed3170bdc109">check_tx_inputs</a> (const std::function&lt; <a class="el" href="classcryptonote_1_1transaction.html">cryptonote::transaction</a> &amp;()&gt; &amp;get_tx, const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;txid, uint64_t &amp;max_used_block_height, <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;max_used_block_id, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;tvc, <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> kept_by_block=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>, uint64_t *blink_rollback_height=nullptr) const</td></tr>
<tr class="memdesc:ae6d30e317c1b946903d0ed3170bdc109"><td class="mdescLeft">&#160;</td><td class="mdescRight">cache/call <a class="el" href="classcryptonote_1_1Blockchain.html#afcca64964ff6585f4f70af9680557839" title="validates a transaction&#39;s inputs">Blockchain::check_tx_inputs</a> results  <a href="classcryptonote_1_1tx__memory__pool.html#ae6d30e317c1b946903d0ed3170bdc109">More...</a><br /></td></tr>
<tr class="separator:ae6d30e317c1b946903d0ed3170bdc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93308b7d5cfc2d4285f2bb83b0e0ad7d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt;, std::vector&lt; uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a93308b7d5cfc2d4285f2bb83b0e0ad7d">get_blink_hashes_and_mined_heights</a> () const</td></tr>
<tr class="separator:a93308b7d5cfc2d4285f2bb83b0e0ad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af6636b9a2711cc5e296bcd7f526983a9"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#af6636b9a2711cc5e296bcd7f526983a9">m_transactions_lock</a></td></tr>
<tr class="memdesc:af6636b9a2711cc5e296bcd7f526983a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for the pool  <a href="classcryptonote_1_1tx__memory__pool.html#af6636b9a2711cc5e296bcd7f526983a9">More...</a><br /></td></tr>
<tr class="separator:af6636b9a2711cc5e296bcd7f526983a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c458ea137674784b35e9d146ece8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">key_images_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a6a2c458ea137674784b35e9d146ece8e">m_spent_key_images</a></td></tr>
<tr class="memdesc:a6a2c458ea137674784b35e9d146ece8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">container for spent key images from the transactions in the pool  <a href="classcryptonote_1_1tx__memory__pool.html#a6a2c458ea137674784b35e9d146ece8e">More...</a><br /></td></tr>
<tr class="separator:a6a2c458ea137674784b35e9d146ece8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c18bba98acf9ed2cdd03c891ecea91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtools_1_1periodic__task.html">tools::periodic_task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#af2c18bba98acf9ed2cdd03c891ecea91">m_remove_stuck_tx_interval</a> {30s}</td></tr>
<tr class="memdesc:af2c18bba98acf9ed2cdd03c891ecea91"><td class="mdescLeft">&#160;</td><td class="mdescRight">interval on which to check for stale/"stuck" transactions  <a href="classcryptonote_1_1tx__memory__pool.html#af2c18bba98acf9ed2cdd03c891ecea91">More...</a><br /></td></tr>
<tr class="separator:af2c18bba98acf9ed2cdd03c891ecea91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d8773b05f8415e5fb5d031bc57fff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecryptonote.html#a519318e9f47111feb31d73d79a8003de">sorted_tx_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a92d8773b05f8415e5fb5d031bc57fff1">m_txs_by_fee_and_receive_time</a></td></tr>
<tr class="memdesc:a92d8773b05f8415e5fb5d031bc57fff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; container for transactions organized by fee per size and receive time  <a href="classcryptonote_1_1tx__memory__pool.html#a92d8773b05f8415e5fb5d031bc57fff1">More...</a><br /></td></tr>
<tr class="separator:a92d8773b05f8415e5fb5d031bc57fff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcbd1baa408b2f7484b18bd848bd6a6"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#acfcbd1baa408b2f7484b18bd848bd6a6">m_cookie</a></td></tr>
<tr class="memdesc:acfcbd1baa408b2f7484b18bd848bd6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">incremented at each change  <a href="classcryptonote_1_1tx__memory__pool.html#acfcbd1baa408b2f7484b18bd848bd6a6">More...</a><br /></td></tr>
<tr class="separator:acfcbd1baa408b2f7484b18bd848bd6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b641ee33f547d5603e14b9514a47aec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void(const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;, const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;, const std::string &amp;blob, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a9b641ee33f547d5603e14b9514a47aec">m_tx_notify</a></td></tr>
<tr class="memdesc:a9b641ee33f547d5603e14b9514a47aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks for new tx notifications.  <a href="classcryptonote_1_1tx__memory__pool.html#a9b641ee33f547d5603e14b9514a47aec">More...</a><br /></td></tr>
<tr class="separator:a9b641ee33f547d5603e14b9514a47aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b44eef259469c4cbbf2760fd9804933"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a6b44eef259469c4cbbf2760fd9804933">m_timed_out_transactions</a></td></tr>
<tr class="memdesc:a6b44eef259469c4cbbf2760fd9804933"><td class="mdescLeft">&#160;</td><td class="mdescRight">transactions which are unlikely to be included in blocks  <a href="classcryptonote_1_1tx__memory__pool.html#a6b44eef259469c4cbbf2760fd9804933">More...</a><br /></td></tr>
<tr class="separator:a6b44eef259469c4cbbf2760fd9804933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972c861f927a7127042c87a9fadbbed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a972c861f927a7127042c87a9fadbbed0">m_blockchain</a></td></tr>
<tr class="memdesc:a972c861f927a7127042c87a9fadbbed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to the <a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> object  <a href="classcryptonote_1_1tx__memory__pool.html#a972c861f927a7127042c87a9fadbbed0">More...</a><br /></td></tr>
<tr class="separator:a972c861f927a7127042c87a9fadbbed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5925b0e9f166ba16947525b278601a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a4e5925b0e9f166ba16947525b278601a">m_txpool_max_weight</a></td></tr>
<tr class="separator:a4e5925b0e9f166ba16947525b278601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade870150c431217bb94718b4de61b669"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ade870150c431217bb94718b4de61b669">m_txpool_weight</a></td></tr>
<tr class="separator:ade870150c431217bb94718b4de61b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec31bcfbd9fcdb603103a8b18e4ba1a"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::tuple&lt; <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a>, uint64_t, <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#abec31bcfbd9fcdb603103a8b18e4ba1a">m_input_cache</a></td></tr>
<tr class="separator:abec31bcfbd9fcdb603103a8b18e4ba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad386ffa8ca0ccb68c7bbc95031a05926"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ad386ffa8ca0ccb68c7bbc95031a05926">m_parsed_tx_cache</a></td></tr>
<tr class="separator:ad386ffa8ca0ccb68c7bbc95031a05926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1f7a8e08fea6ffe32904af0a99935c"><td class="memItemLeft" align="right" valign="top">std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a0e1f7a8e08fea6ffe32904af0a99935c">m_blinks_mutex</a></td></tr>
<tr class="separator:a0e1f7a8e08fea6ffe32904af0a99935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1079cd70f9107447f221095781d78639"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">cryptonote::blink_tx</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#a1079cd70f9107447f221095781d78639">m_blinks</a></td></tr>
<tr class="separator:a1079cd70f9107447f221095781d78639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transaction pool, handles transactions which are not part of a block. </p>
<p>This class handles all transactions which have been received, but not as part of a block.</p>
<p>This handling includes: storing the transactions organizing the transactions by fee per weight unit taking/giving transactions to and from various other components saving the transactions to disk on shutdown helping create a new block template by choosing transactions for it </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac8db608d610e9b31288681ab018ae2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8db608d610e9b31288681ab018ae2e9">&#9670;&nbsp;</a></span>key_images_container</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">cryptonote::tx_memory_pool::key_images_container</a> =  std::unordered_map&lt;<a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a>, std::unordered_set&lt;<a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>map key images to transactions which spent them </p>
<p>this seems odd, but it seems that multiple transactions can exist in the pool which both have the same spent key. This would happen in the event of a reorg where someone creates a new/different transaction on the assumption that the original will not be in a block again. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a992c709afc7268d0d9cf23485095d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992c709afc7268d0d9cf23485095d98f">&#9670;&nbsp;</a></span>tx_memory_pool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cryptonote::tx_memory_pool::tx_memory_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> &amp;&#160;</td>
          <td class="paramname"><em>bchs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bchs</td><td>a <a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> class instance, for getting chain info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a78c369e288d5d5ff853cc5f42325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a78c369e288d5d5ff853cc5f42325e">&#9670;&nbsp;</a></span>tx_memory_pool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cryptonote::tx_memory_pool::tx_memory_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3d69f56ad1b8807de5d3ff108543433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d69f56ad1b8807de5d3ff108543433">&#9670;&nbsp;</a></span>add_existing_blink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::add_existing_blink </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt;&#160;</td>
          <td class="paramname"><em>blink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to add blink transaction information about an existing blink transaction </p>
<p>You <em>must</em> already hold a <a class="el" href="classcryptonote_1_1tx__memory__pool.html#a010a25d6e7eb662d6c29c732da0ee1c2" title="obtains a unique lock on the approved blink tx pool">blink_unique_lock()</a>.</p>
<p>This method takes an approved <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> and records it in the known blinks data. No check is done that the transaction actually exists on the blockchain or mempool. It is assumed that the given shared_ptr is a new blink that is not yet shared between threads (and thus doesn't need locking): sharing is expected only after it is added to the blinks via this method.</p>
<p>NB: this function assumes that the given blink tx is valid and approved (signed) but does <em>not</em> check it (except as an assert when compiling in debug mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blink</td><td>the <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> shared_ptr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the blink data was recorded, false if the given blink was already known. </dd></dl>

</div>
</div>
<a id="a013deee6f30a649f65430ab8f27aa1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013deee6f30a649f65430ab8f27aa1ea">&#9670;&nbsp;</a></span>add_new_blink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::add_new_blink </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;&#160;</td>
          <td class="paramname"><em>tvc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>blink_exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to add a blink transaction to the transaction pool. </p>
<p>This method must be called without a held blink lock.</p>
<p>This is only for use for new transactions that should not exist yet on the chain or mempool (and will fail if already does). See <code>add_existing_blink</code> instead to add blink data about a transaction that already exists. This is only meant to be called during the SN blink signing phase (and requires that the <code>tx</code> transaction be properly set to a full transaction); ordinary nodes receiving a blink tx from the network should be going through core.handle_incoming_blinks instead.</p>
<p>Whether or not the transaction is added to the known blinks or marked for relaying depends on whether the passed-in transaction has an <code>.approved()</code> status: if it does, the transaction is set for relaying and added to the active blinks immediately; otherwise it is not added to the known blinks and will not be relayed.</p>
<p>The transaction is <em>not</em> added to the known blinks or marked for relaying unless it is passed in with an <code>.approved()</code> status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blink</td><td>- a shared_ptr to the blink details </td></tr>
    <tr><td class="paramname">tvc</td><td>- the verification results </td></tr>
    <tr><td class="paramname">blink_exists</td><td>- will be set to true if the addition fails because the blink tx already exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the tx passes validations and has been added to the tx pool. </dd></dl>

</div>
</div>
<a id="ae7fe5dc73d036d7ea07ac632317b6113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe5dc73d036d7ea07ac632317b6113">&#9670;&nbsp;</a></span>add_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::add_notify </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;, const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;, const std::string &amp;blob, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>notify</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies a callback to invoke when one or more transactions is added to the mempool. Note that, because incoming blocks have their transactions added to the mempool, this <em>does</em> trigger for txes that arrive in new blocks.</p>
<p>It does not, however, trigger for transactions that fail verification, that are flagged do-not-relay, or that are returned to the pool from a block (i.e. when doing a reorg). </p>

</div>
</div>
<a id="ad5946446c0e38b9e05b10bc658f949c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5946446c0e38b9e05b10bc658f949c9">&#9670;&nbsp;</a></span>add_tx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::add_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tx_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;&#160;</td>
          <td class="paramname"><em>tvc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a>&#160;</td>
          <td class="paramname"><em>hf_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>blink_rollback_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a transaction to the transaction pool </p>
<p>Most likely the transaction will come from the network, but it is also possible for transactions to come from popped blocks during a reorg, or from local clients creating a transaction and submitting it to the network</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the transaction to be added </td></tr>
    <tr><td class="paramname">tvc</td><td>return-by-reference status about the transaction verification </td></tr>
    <tr><td class="paramname">opts</td><td>the options controlling how this tx will be accepted/added </td></tr>
    <tr><td class="paramname">hf_version</td><td>the hard fork version used to create the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction passes validations, otherwise false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the transaction's hash </td></tr>
    <tr><td class="paramname">tx_weight</td><td>the transaction's weight </td></tr>
    <tr><td class="paramname">blink_rollback_height</td><td>if tx is a blink that conflicts with a recent (non-immutable) block tx then set this pointer to the required new height: that is, all blocks with height <code>block_rollback_height</code> and above must be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7005556ce18cb58faf0d6045b0dd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7005556ce18cb58faf0d6045b0dd22">&#9670;&nbsp;</a></span>add_tx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::add_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;&#160;</td>
          <td class="paramname"><em>tvc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a>&#160;</td>
          <td class="paramname"><em>hf_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a transaction to the transaction pool </p>
<p>Most likely the transaction will come from the network, but it is also possible for transactions to come from popped blocks during a reorg, or from local clients creating a transaction and submitting it to the network</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the transaction to be added </td></tr>
    <tr><td class="paramname">tvc</td><td>return-by-reference status about the transaction verification </td></tr>
    <tr><td class="paramname">opts</td><td>the options controlling how this tx will be accepted/added </td></tr>
    <tr><td class="paramname">hf_version</td><td>the hard fork version used to create the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction passes validations, otherwise false </dd></dl>

</div>
</div>
<a id="af13906ba925503f7de4bacfca1f1497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13906ba925503f7de4bacfca1f1497c">&#9670;&nbsp;</a></span>blink_shared_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cryptonote::tx_memory_pool::blink_shared_lock </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obtains a shared lock on the approved blink tx pool </p>

</div>
</div>
<a id="a010a25d6e7eb662d6c29c732da0ee1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010a25d6e7eb662d6c29c732da0ee1c2">&#9670;&nbsp;</a></span>blink_unique_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cryptonote::tx_memory_pool::blink_unique_lock </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obtains a unique lock on the approved blink tx pool </p>

</div>
</div>
<a id="aec13cc81f2955d9f39bf3273791a3e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec13cc81f2955d9f39bf3273791a3e21">&#9670;&nbsp;</a></span>check_for_key_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::check_for_key_images </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key_images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check for presence of key images in the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_images</td><td>[in] vector of key images to check </td></tr>
    <tr><td class="paramname">spent</td><td>[out] vector of bool to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="ae6d30e317c1b946903d0ed3170bdc109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d30e317c1b946903d0ed3170bdc109">&#9670;&nbsp;</a></span>check_tx_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::check_tx_inputs </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classcryptonote_1_1transaction.html">cryptonote::transaction</a> &amp;()&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>max_used_block_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>max_used_block_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a> &amp;&#160;</td>
          <td class="paramname"><em>tvc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>kept_by_block</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>blink_rollback_height</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cache/call <a class="el" href="classcryptonote_1_1Blockchain.html#afcca64964ff6585f4f70af9680557839" title="validates a transaction&#39;s inputs">Blockchain::check_tx_inputs</a> results </p>

</div>
</div>
<a id="a7126ff436715b0012c73a78cc83ca0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126ff436715b0012c73a78cc83ca0b1">&#9670;&nbsp;</a></span>cookie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cryptonote::tx_memory_pool::cookie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the cookie </p>
<dl class="section return"><dt>Returns</dt><dd>the cookie </dd></dl>

</div>
</div>
<a id="afea956b17732998b8143d6d3d8e0ba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea956b17732998b8143d6d3d8e0ba7b">&#9670;&nbsp;</a></span>deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::deinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to save the transaction pool state to disk </p>
<p>Currently fails (returns false) if the data directory from <a class="el" href="classcryptonote_1_1tx__memory__pool.html#a82ef1c5e089c16db7f09595a092d1825" title="loads pool state (if any) from disk, and initializes pool">init()</a> does not exist and cannot be created, but returns true even if saving to disk is unsuccessful.</p>
<dl class="section return"><dt>Returns</dt><dd>true in most cases (see above) </dd></dl>

</div>
</div>
<a id="a1211f3aefd5033931d168da4e78fd80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1211f3aefd5033931d168da4e78fd80a">&#9670;&nbsp;</a></span>fill_block_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::fill_block_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1block.html">block</a> &amp;&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>median_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>already_generated_coins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>total_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>raw_fee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>expected_reward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a>&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses transactions for a block to include. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>return-by-reference the block to fill in with transactions </td></tr>
    <tr><td class="paramname">median_weight</td><td>the current median block weight </td></tr>
    <tr><td class="paramname">already_generated_coins</td><td>the current total number of coins "minted" </td></tr>
    <tr><td class="paramname">total_weight</td><td>return-by-reference the total weight of the new block </td></tr>
    <tr><td class="paramname">raw_fee</td><td>return-by-reference the total of fees from the included transactions. Note that this does not subtract any large block penalty fees; this is just the raw sum of fees of included txes. </td></tr>
    <tr><td class="paramname">expected_reward</td><td>return-by-reference the total reward awarded to the block producer finding this block, including transaction fees and, if applicable, a large block reward penalty. </td></tr>
    <tr><td class="paramname">version</td><td>hard fork version to use for consensus rules</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a9946ac23813b0846275575e79b37bcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9946ac23813b0846275575e79b37bcc8">&#9670;&nbsp;</a></span>find_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cryptonote::tx_memory_pool::find_transactions </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx_hashes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>txblobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get specific transactions from the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>- tx hashes of desired transactions </td></tr>
    <tr><td class="paramname">txblobs</td><td>- vector of std::string (i.e. std::strings) to which found blobs should be appended. The vector is <em>not</em> cleared of existing values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of transactions added to txblobs </dd></dl>

</div>
</div>
<a id="a0a84ffb957eeda11ec3ef752bb9cb2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84ffb957eeda11ec3ef752bb9cb2fc">&#9670;&nbsp;</a></span>find_tx_in_sorted_container()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sorted_tx_container::iterator cryptonote::tx_memory_pool::find_tx_in_sorted_container </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get an iterator to a transaction in the sorted container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the hash of the transaction to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator, possibly to the end of the container if not found </dd></dl>

</div>
</div>
<a id="a4e9a263a86f5966b6b49421aaed989ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9a263a86f5966b6b49421aaed989ec">&#9670;&nbsp;</a></span>get_blink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcryptonote_1_1blink__tx.html">blink_tx</a> &gt; cryptonote::tx_memory_pool::get_blink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>tx_hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>accesses blink tx details if the given tx hash is a known, approved blink tx, nullptr otherwise. </p>
<p>You <em>must</em> already hold a <a class="el" href="classcryptonote_1_1tx__memory__pool.html#af13906ba925503f7de4bacfca1f1497c" title="obtains a shared lock on the approved blink tx pool">blink_shared_lock()</a> or <a class="el" href="classcryptonote_1_1tx__memory__pool.html#a010a25d6e7eb662d6c29c732da0ee1c2" title="obtains a unique lock on the approved blink tx pool">blink_unique_lock()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_hash</td><td>the hash of the tx to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab424e94187ab40930a39b273ac6f31d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab424e94187ab40930a39b273ac6f31d7">&#9670;&nbsp;</a></span>get_blink_checksums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; uint64_t, <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; cryptonote::tx_memory_pool::get_blink_checksums </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns checksums of blink txes included in recently mined blocks and in the mempool </p>
<p>Must not currently hold a blink lock.</p>
<p>The returned map consists of height =&gt; hashsum pairs where the height is the height in which the blink transactions were mined and the hashsum is a checksum of all the blink txes mined at that height. Unmined mempool blink txes are included at a height of 0. Only heights since the immutable checkpoint block are included. Any block height (including the special "0" height) that has no blink tx in it is not included. </p>

</div>
</div>
<a id="a93308b7d5cfc2d4285f2bb83b0e0ad7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93308b7d5cfc2d4285f2bb83b0e0ad7d">&#9670;&nbsp;</a></span>get_blink_hashes_and_mined_heights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt;, std::vector&lt; uint64_t &gt; &gt; cryptonote::tx_memory_pool::get_blink_hashes_and_mined_heights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a1b40549be4e5ce2575db5736f591ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1b40549be4e5ce2575db5736f591ce">&#9670;&nbsp;</a></span>get_mined_blinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; cryptonote::tx_memory_pool::get_mined_blinks </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>heights</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the hashes of any non-immutable blink transactions mined in the given heights. A height of 0 is allowed: it indicates blinks in the mempool. </p>
<p>Must not currently hold a blink lock.</p>
<p>Note that this returned hashes by MINED HEIGHTS, not BLINK HEIGHTS where are a different concept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>of heights</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of hashes </dd></dl>

</div>
</div>
<a id="ada0bbc05821f25c43f87818dd048e2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0bbc05821f25c43f87818dd048e2be">&#9670;&nbsp;</a></span>get_relayable_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::get_relayable_transactions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>txs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a list of all relayable transactions and their hashes </p>
<p>"relayable" in this case means: nonzero fee -or- a zero-fee SN state change tx hasn't been relayed too recently isn't old enough that relaying it is considered harmful doesn't have do_not_relay set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txs</td><td>return-by-reference the transactions and their hashes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a3c5681132864da1374850641c1e35f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5681132864da1374850641c1e35f2e">&#9670;&nbsp;</a></span>get_spent_key_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">tx_memory_pool::key_images_container</a> cryptonote::tx_memory_pool::get_spent_key_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>already_locked</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the map of key images -&gt; set of transactions which spent them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">already_locked</td><td>can be passed as true if the caller already has a lock on the blockchain and mempool objects; otherwise a new lock will be obtained by the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8afa235429f2aad604d7a01bf8117c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afa235429f2aad604d7a01bf8117c55">&#9670;&nbsp;</a></span>get_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::get_transaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>txblob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a specific transaction from the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the hash of the transaction to get </td></tr>
    <tr><td class="paramname">tx</td><td>return-by-reference the transaction blob requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction is found, otherwise false </dd></dl>

</div>
</div>
<a id="a3d0b85b526e1d7cf27a58b076270c52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0b85b526e1d7cf27a58b076270c52b">&#9670;&nbsp;</a></span>get_transaction_hashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::get_transaction_hashes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>txs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>include_unrelayed_txes</em> = <code><a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>include_only_blinked</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a list of all transaction hashes in the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txs</td><td>return-by-reference the list of transactions </td></tr>
    <tr><td class="paramname">include_unrelayed_txes</td><td>include unrelayed txes in the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc6a4f1b878b42f63e3fbf99643c591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6a4f1b878b42f63e3fbf99643c591c">&#9670;&nbsp;</a></span>get_transaction_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcryptonote_1_1tx__memory__pool_1_1tx__stats.html">tx_memory_pool::tx_stats</a> cryptonote::tx_memory_pool::get_transaction_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>include_unrelayed_txes</em> = <code><a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a summary statistics of all transaction hashes in the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">include_unrelayed_txes</td><td>include unrelayed txes in the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>txpool_stats struct of pool statistics </dd></dl>

</div>
</div>
<a id="a781505a42371a8461edb4047bf6c2046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781505a42371a8461edb4047bf6c2046">&#9670;&nbsp;</a></span>get_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::get_transactions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>txs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>include_unrelayed_txes</em> = <code><a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a list of all transactions in the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txs</td><td>return-by-reference the list of transactions </td></tr>
    <tr><td class="paramname">include_unrelayed_txes</td><td>include unrelayed txes in the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac819deab6187cd28a7a1233114b287d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac819deab6187cd28a7a1233114b287d5">&#9670;&nbsp;</a></span>get_transactions_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cryptonote::tx_memory_pool::get_transactions_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>include_unrelayed_txes</em> = <code><a class="el" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the total number of transactions in the pool </p>
<dl class="section return"><dt>Returns</dt><dd>the number of transactions in the pool </dd></dl>

</div>
</div>
<a id="ab572c0afc555ae393a8df2dcc0f00673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab572c0afc555ae393a8df2dcc0f00673">&#9670;&nbsp;</a></span>get_txpool_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cryptonote::tx_memory_pool::get_txpool_weight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the cumulative txpool weight in bytes </p>
<dl class="section return"><dt>Returns</dt><dd>the cumulative txpool weight in bytes </dd></dl>

</div>
</div>
<a id="aa99a39234919dfe66897951fa0bb5241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99a39234919dfe66897951fa0bb5241">&#9670;&nbsp;</a></span>has_blink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::has_blink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>tx_hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to <code>(bool) get_blink(...)</code>, but slightly more efficient when the blink information isn't actually needed beyond an existance test (as it avoids copying the shared_ptr).</p>
<p>You <em>must</em> already hold a <a class="el" href="classcryptonote_1_1tx__memory__pool.html#af13906ba925503f7de4bacfca1f1497c" title="obtains a shared lock on the approved blink tx pool">blink_shared_lock()</a> or <a class="el" href="classcryptonote_1_1tx__memory__pool.html#a010a25d6e7eb662d6c29c732da0ee1c2" title="obtains a unique lock on the approved blink tx pool">blink_unique_lock()</a>. </p>

</div>
</div>
<a id="ac624b3e7995eaecac7bd77d28b21836d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac624b3e7995eaecac7bd77d28b21836d">&#9670;&nbsp;</a></span>have_duplicated_non_standard_tx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::have_duplicated_non_standard_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1transaction.html">transaction</a> const &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a tx that does not have a key-image component has a duplicate in the pool </p>
<dl class="section return"><dt>Returns</dt><dd>true if it already exists </dd></dl>

</div>
</div>
<a id="a54c005079be92dc34c487216278086e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c005079be92dc34c487216278086e4">&#9670;&nbsp;</a></span>have_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::have_tx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the pool has a transaction with the given hash </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the hash to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction is in the pool, otherwise false </dd></dl>

</div>
</div>
<a id="adc095de20f5654b4642f947a08d5e6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc095de20f5654b4642f947a08d5e6ec">&#9670;&nbsp;</a></span>have_tx_keyimg_as_spent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::have_tx_keyimg_as_spent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1key__image.html">crypto::key_image</a> &amp;&#160;</td>
          <td class="paramname"><em>key_im</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a transaction in the pool has a given spent key image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_im</td><td>the spent key image to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the spent key image is present, otherwise false </dd></dl>

</div>
</div>
<a id="a9360c129a0323bf11804be1764102f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360c129a0323bf11804be1764102f55">&#9670;&nbsp;</a></span>have_tx_keyimges_as_spent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::have_tx_keyimges_as_spent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; *&#160;</td>
          <td class="paramname"><em>conflicting</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if any spent key image in a transaction is in the pool </p>
<p>Checks if any of the spent key images in a given transaction are present in any of the transactions in the transaction pool.</p>
<dl class="section note"><dt>Note</dt><dd>see tx_pool::have_tx_keyimg_as_spent</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the transaction to check spent key images of </td></tr>
    <tr><td class="paramname">found</td><td>if specified, append the hashes of all conflicting mempool txes here</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any spent key images are present in the pool, otherwise false </dd></dl>

</div>
</div>
<a id="ae6710a00d13e4ddc0a1974b391ae85aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6710a00d13e4ddc0a1974b391ae85aa">&#9670;&nbsp;</a></span>have_txs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; cryptonote::tx_memory_pool::have_txs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines whether the given tx hashes are in the mempool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>vector of tx hashes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the same size as <code>hashes</code> of true (1) or false (0) values. (Not using std::vector&lt;bool&gt; because it is broken by design). </dd></dl>

</div>
</div>
<a id="a82ef1c5e089c16db7f09595a092d1825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ef1c5e089c16db7f09595a092d1825">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_txpool_weight</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loads pool state (if any) from disk, and initializes pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_txpool_weight</td><td>the max weight in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="ad93aa45381a8ba23afbba87e50aa6e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93aa45381a8ba23afbba87e50aa6e4b">&#9670;&nbsp;</a></span>insert_key_images()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::insert_key_images </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1transaction__prefix.html">transaction_prefix</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>kept_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert key images into m_spent_key_images </p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error </dd></dl>

</div>
</div>
<a id="a223200675e9cb2dc9c748163664fc7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223200675e9cb2dc9c748163664fc7e0">&#9670;&nbsp;</a></span>is_transaction_ready_to_go()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::is_transaction_ready_to_go </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1txpool__tx__meta__t.html">txpool_tx_meta_t</a> &amp;&#160;</td>
          <td class="paramname"><em>txd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txblob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a transaction is a valid candidate for inclusion in a block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txd</td><td>the transaction to check (and info about it) </td></tr>
    <tr><td class="paramname">txid</td><td>the txid of the transaction to check </td></tr>
    <tr><td class="paramname">txblob</td><td>the transaction blob to check </td></tr>
    <tr><td class="paramname">tx</td><td>the parsed transaction, if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction is good to go, otherwise false </dd></dl>

</div>
</div>
<a id="a60742c292f673da41e8906e1ce18b59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60742c292f673da41e8906e1ce18b59c">&#9670;&nbsp;</a></span>keep_missing_blinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::keep_missing_blinks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx_hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>modifies a vector of tx hashes to remove any that have known valid blink signatures </p>
<p>Must not currently hold a blink lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txs</td><td>the tx hashes to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e718457416f64580f4dfdc4e9926cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e718457416f64580f4dfdc4e9926cbd">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>locks the transaction pool </p>

</div>
</div>
<a id="ab421ff4baa8437324f4e3a6b2fb4e138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab421ff4baa8437324f4e3a6b2fb4e138">&#9670;&nbsp;</a></span>mark_double_spend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::mark_double_spend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mark all transactions double spending the one passed </p>

</div>
</div>
<a id="ae6da06ddc8334f31dd69aecffdcf948e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6da06ddc8334f31dd69aecffdcf948e">&#9670;&nbsp;</a></span>on_blockchain_dec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::on_blockchain_dec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>action to take when notified of a block removed from the blockchain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block_height</td><td>the height of the blockchain after the change </td></tr>
    <tr><td class="paramname">top_block_id</td><td>the hash of the new top block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a5d217ba322d9d2e06500411fffe07d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d217ba322d9d2e06500411fffe07d67">&#9670;&nbsp;</a></span>on_blockchain_inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::on_blockchain_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcryptonote_1_1block.html">block</a> const &amp;&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>action to take when notified of a block added to the blockchain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block_height</td><td>the height of the blockchain after the change </td></tr>
    <tr><td class="paramname">top_block_id</td><td>the hash of the new top block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a1b272997a403b2f451820e890ba628b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b272997a403b2f451820e890ba628b0">&#9670;&nbsp;</a></span>on_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::on_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>action to take periodically </p>
<p>Currently checks transaction pool for stale ("stuck") transactions </p>

</div>
</div>
<a id="a48b0ca004bbdd657127cb3e85d986619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b0ca004bbdd657127cb3e85d986619">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a>&amp; cryptonote::tx_memory_pool::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1tx__memory__pool.html">tx_memory_pool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace60037187690f98fe07f18c3daf32f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace60037187690f98fe07f18c3daf32f4">&#9670;&nbsp;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>skip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prune lowest fee/byte txes till we're not above bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skip</td><td>don't prune the given ID this time (because it was just added) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb2c77087275ab6ff7759b773f8de15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb2c77087275ab6ff7759b773f8de15">&#9670;&nbsp;</a></span>remove_blink_conflicts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::remove_blink_conflicts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conflict_txs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>blink_rollback_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to add a blink tx "by force", removing conflicting non-blink txs. </p>
<p>The given transactions are removed from the mempool, if possible, to make way for this blink transactions. In order for any removal to happen, all the conflicting txes must be non-blink transactions, and must either:</p><ul>
<li>be a mempool transaction</li>
<li>be a mined, non-blink transaction in the recent (mutable) section of the chain</li>
</ul>
<p>If all conflicting txs satisfy the above then conflicting mempool txs are removed and the blink_rollback_height pointer is updated to the required rollback height to eject any mined txs (if not already at that height or lower). True is returned.</p>
<p>If any txs are found that do not satisfy the above then nothing is removed and false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>id of the incoming blink tx </td></tr>
    <tr><td class="paramname">conflict_txs</td><td>vector of conflicting transaction hashes that are preventing the blink tx </td></tr>
    <tr><td class="paramname">blink_rollback_height</td><td>a pointer to update to the new required height if a chain rollback is needed for the blink tx. (That is, all blocks with height &gt;= blink_rollback_height need to be popped).</td></tr>
  </table>
  </dd>
</dl>
<p>This method is <em>not</em> called with a blink lock held.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the conflicting transactions have been removed (and/or the rollback height set), false if tx removal and/or rollback are insufficient to eliminate conflicting txes. </dd></dl>

</div>
</div>
<a id="aad00ed4cce2351c261925dfbde1b0a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad00ed4cce2351c261925dfbde1b0a1e">&#9670;&nbsp;</a></span>remove_stuck_transactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::remove_stuck_transactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove old transactions from the pool </p>
<p>After a certain time, it is assumed that a transaction which has not yet been mined will likely not be mined. These transactions are removed from the pool to avoid buildup.</p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a3fea8a79996be4896421a1d492414098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fea8a79996be4896421a1d492414098">&#9670;&nbsp;</a></span>remove_transaction_keyimages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::remove_transaction_keyimages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcryptonote_1_1transaction__prefix.html">transaction_prefix</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forget a transaction's spent key images </p>
<p>Spent key images are stored separately from transactions for convenience/speed, so this is part of the process of removing a transaction from the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the transaction </td></tr>
    <tr><td class="paramname">txid</td><td>the transaction's hash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if any key images to be removed cannot be found, otherwise true </dd></dl>

</div>
</div>
<a id="a2371b71c2f9d0307a28fc2f9638c00f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371b71c2f9d0307a28fc2f9638c00f3">&#9670;&nbsp;</a></span>remove_tx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::remove_tx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcryptonote_1_1txpool__tx__meta__t.html">txpool_tx_meta_t</a> *&#160;</td>
          <td class="paramname"><em>meta</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sorted_tx_container::iterator *&#160;</td>
          <td class="paramname"><em>stc_it</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove a transaction from the mempool </p>
<p>This is called when pruning the mempool to reduce its size, and when deleting transactions from the mempool because of a conflicting blink transaction arriving. Transactions lock and blockchain lock must be held by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txid</td><td>the transaction id to remove </td></tr>
    <tr><td class="paramname">meta</td><td>optional pointer to <a class="el" href="structcryptonote_1_1txpool__tx__meta__t.html" title="a struct containing txpool per transaction metadata">txpool_tx_meta_t</a>; will be looked up if omitted </td></tr>
    <tr><td class="paramname">stc_it</td><td>an optional iterator to the tx's entry in m_txs_by_fee_and_receive_time to save a (linear) scan to find it when already available. The given iterator will be invalidated if removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction was removed, false on failure. </dd></dl>

</div>
</div>
<a id="a2a0cf4b37f2feb1653ac96a83945cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0cf4b37f2feb1653ac96a83945cca3">&#9670;&nbsp;</a></span>set_relayable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cryptonote::tx_memory_pool::set_relayable </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tx_hashes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear transactions' <code>do_not_relay</code> flags (if set) so that they can start being relayed. (Note that it still must satisfy the other conditions of <code>get_relayable_transactions</code> to actually be relayable). </p>
<dl class="section return"><dt>Returns</dt><dd>the number of txes that were found with an active <code>do_not_relay</code> flag that was cleared. </dd></dl>

</div>
</div>
<a id="acec0c2d4cc416d504e4ceabbb175edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0c2d4cc416d504e4ceabbb175edc2">&#9670;&nbsp;</a></span>set_relayed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::set_relayed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>txs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tell the pool that certain transactions were just relayed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txs</td><td>the list of transactions (and their hashes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b8b8aba76dc6dac3ef345367574f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b8b8aba76dc6dac3ef345367574f69">&#9670;&nbsp;</a></span>set_txpool_max_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::set_txpool_max_weight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the max cumulative txpool weight in bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the max cumulative txpool weight in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2bba96b565d97b87f2a90fef343eba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bba96b565d97b87f2a90fef343eba0">&#9670;&nbsp;</a></span>take_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::take_tx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcryptonote_1_1transaction.html">transaction</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>txblob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>tx_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>fee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>relayed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>do_not_relay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>double_spend_seen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>takes a transaction with the given hash from the pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the hash of the transaction </td></tr>
    <tr><td class="paramname">tx</td><td>return-by-reference the transaction taken </td></tr>
    <tr><td class="paramname">txblob</td><td>return-by-reference the transaction as a blob </td></tr>
    <tr><td class="paramname">tx_weight</td><td>return-by-reference the transaction's weight </td></tr>
    <tr><td class="paramname">fee</td><td>the transaction fee </td></tr>
    <tr><td class="paramname">relayed</td><td>return-by-reference was transaction relayed to us by the network? </td></tr>
    <tr><td class="paramname">do_not_relay</td><td>return-by-reference is transaction not to be relayed to the network? </td></tr>
    <tr><td class="paramname">double_spend_seen</td><td>return-by-reference was a double spend seen for that transaction?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true unless the transaction cannot be found in the pool </dd></dl>

</div>
</div>
<a id="a65b8179f3f72c219b0afe760d6df55ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b8179f3f72c219b0afe760d6df55ee">&#9670;&nbsp;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> cryptonote::tx_memory_pool::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@briefs does a non-blocking attempt to lock the transaction pool </p>

</div>
</div>
<a id="a011855e34b5f72c21770d3718313ef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011855e34b5f72c21770d3718313ef40">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cryptonote::tx_memory_pool::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unlocks the transaction pool </p>

</div>
</div>
<a id="ac338181c8cdba5f77b645c530de1de7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac338181c8cdba5f77b645c530de1de7a">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cryptonote::tx_memory_pool::validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecryptonote.html#a884c13f6c17c6ce8dd15f2e9bc4c75ef">hf</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove transactions from the pool which are no longer valid </p>
<p>With new versions of the currency, what conditions render a transaction invalid may change. This function clears those which were received before a version change and no longer conform to requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>the version the transactions must conform to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of transactions removed </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1079cd70f9107447f221095781d78639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1079cd70f9107447f221095781d78639">&#9670;&nbsp;</a></span>m_blinks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::shared_ptr&lt;<a class="el" href="classcryptonote_1_1blink__tx.html">cryptonote::blink_tx</a>&gt; &gt; cryptonote::tx_memory_pool::m_blinks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e1f7a8e08fea6ffe32904af0a99935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1f7a8e08fea6ffe32904af0a99935c">&#9670;&nbsp;</a></span>m_blinks_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_mutex cryptonote::tx_memory_pool::m_blinks_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a972c861f927a7127042c87a9fadbbed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972c861f927a7127042c87a9fadbbed0">&#9670;&nbsp;</a></span>m_blockchain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a>&amp; cryptonote::tx_memory_pool::m_blockchain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reference to the <a class="el" href="classcryptonote_1_1Blockchain.html">Blockchain</a> object </p>

</div>
</div>
<a id="acfcbd1baa408b2f7484b18bd848bd6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcbd1baa408b2f7484b18bd848bd6a6">&#9670;&nbsp;</a></span>m_cookie</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint64_t&gt; cryptonote::tx_memory_pool::m_cookie</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>incremented at each change </p>

</div>
</div>
<a id="abec31bcfbd9fcdb603103a8b18e4ba1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec31bcfbd9fcdb603103a8b18e4ba1a">&#9670;&nbsp;</a></span>m_input_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, std::tuple&lt;<a class="el" href="stdbool_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>, <a class="el" href="structcryptonote_1_1tx__verification__context.html">tx_verification_context</a>, uint64_t, <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>&gt; &gt; cryptonote::tx_memory_pool::m_input_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad386ffa8ca0ccb68c7bbc95031a05926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad386ffa8ca0ccb68c7bbc95031a05926">&#9670;&nbsp;</a></span>m_parsed_tx_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>, <a class="el" href="classcryptonote_1_1transaction.html">transaction</a>&gt; cryptonote::tx_memory_pool::m_parsed_tx_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2c18bba98acf9ed2cdd03c891ecea91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c18bba98acf9ed2cdd03c891ecea91">&#9670;&nbsp;</a></span>m_remove_stuck_tx_interval</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtools_1_1periodic__task.html">tools::periodic_task</a> cryptonote::tx_memory_pool::m_remove_stuck_tx_interval {30s}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>interval on which to check for stale/"stuck" transactions </p>

</div>
</div>
<a id="a6a2c458ea137674784b35e9d146ece8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2c458ea137674784b35e9d146ece8e">&#9670;&nbsp;</a></span>m_spent_key_images</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcryptonote_1_1tx__memory__pool.html#ac8db608d610e9b31288681ab018ae2e9">key_images_container</a> cryptonote::tx_memory_pool::m_spent_key_images</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>container for spent key images from the transactions in the pool </p>

</div>
</div>
<a id="a6b44eef259469c4cbbf2760fd9804933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b44eef259469c4cbbf2760fd9804933">&#9670;&nbsp;</a></span>m_timed_out_transactions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>&gt; cryptonote::tx_memory_pool::m_timed_out_transactions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transactions which are unlikely to be included in blocks </p>
<p>These transactions are kept in RAM in case they <em>are</em> included in a block eventually, but this container is not saved to disk. </p>

</div>
</div>
<a id="af6636b9a2711cc5e296bcd7f526983a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6636b9a2711cc5e296bcd7f526983a9">&#9670;&nbsp;</a></span>m_transactions_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::recursive_mutex cryptonote::tx_memory_pool::m_transactions_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mutex for the pool </p>

</div>
</div>
<a id="a9b641ee33f547d5603e14b9514a47aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b641ee33f547d5603e14b9514a47aec">&#9670;&nbsp;</a></span>m_tx_notify</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void(const <a class="el" href="structcrypto_1_1hash.html">crypto::hash</a>&amp;, const <a class="el" href="classcryptonote_1_1transaction.html">transaction</a>&amp;, const std::string&amp; blob, const <a class="el" href="structcryptonote_1_1tx__pool__options.html">tx_pool_options</a>&amp;)&gt; &gt; cryptonote::tx_memory_pool::m_tx_notify</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callbacks for new tx notifications. </p>

</div>
</div>
<a id="a4e5925b0e9f166ba16947525b278601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5925b0e9f166ba16947525b278601a">&#9670;&nbsp;</a></span>m_txpool_max_weight</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cryptonote::tx_memory_pool::m_txpool_max_weight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade870150c431217bb94718b4de61b669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade870150c431217bb94718b4de61b669">&#9670;&nbsp;</a></span>m_txpool_weight</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cryptonote::tx_memory_pool::m_txpool_weight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92d8773b05f8415e5fb5d031bc57fff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d8773b05f8415e5fb5d031bc57fff1">&#9670;&nbsp;</a></span>m_txs_by_fee_and_receive_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecryptonote.html#a519318e9f47111feb31d73d79a8003de">sorted_tx_container</a> cryptonote::tx_memory_pool::m_txs_by_fee_and_receive_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; container for transactions organized by fee per size and receive time </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/cryptonote_core/<a class="el" href="tx__pool_8h_source.html">tx_pool.h</a></li>
<li>src/cryptonote_core/<a class="el" href="tx__pool_8cpp.html">tx_pool.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 21 2022 01:12:10 for Monero by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
